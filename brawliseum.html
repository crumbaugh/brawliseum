<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Phaser - Making your first game, part 1</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

"use strict";
var game = new Phaser.Game(800, 600, Phaser.CANVAS, '', { preload: preload, create: create, update: update });
var player, playerHealth, playerHealthText, sword, enemy, enemyHealth, enemyHealthText, upkey, downkey, leftkey, rightkey, speed, attacking, attackFrame, currAttack, startingRotationDifference, startingPositionDifferenceX, startingPositionDifferenceY, jab1, jab2, jab3, queuedAttack, attackString, queuedString, block, enemyHit;
var attacks = new Array(6);
var returnTime = 8;
var blockTime = 8;

function preload() {
    game.load.image('sky', 'assets/sky.png');
    game.load.image('ground', 'assets/platform.png');
    game.load.image('star', 'assets/star.png'); 
    game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
}

class Attack {
    constructor(num, frames, movements, rotations, hitboxes) {
    this.attackNumber = num;
	this.frames       = frames;
    this.movements    = movements;
	this.rotations    = rotations;
	this.hitboxes     = hitboxes;
    }
}

function update() {
    move();
    if (game.input.mouse.button == 0 && this.formerMouse == -1 && currAttack != -1){ 
	    if (currAttack == 0) {
            currAttack = jab1;
            attackString = "jab1";
        } else if (attackString == "jab1" && attacks[currAttack].hitboxes[attackFrame] != 0) {
            attackFrame = 0;
            currAttack = -1;
            queuedAttack = jab2;
            queuedString = "jab2";
        } else if (attackString == "jab2" && attacks[currAttack].hitboxes[attackFrame] != 0) {
            attackFrame = 0;
            currAttack = -1;
            queuedAttack = jab3;
            queuedString = "jab3";
        }
    } else if (game.input.mouse.button == 2 && currAttack != -1) {
	    if (currAttack == 0 && this.formerMouse == -1) {
	        currAttack = block;
        } else if (this.formerMouse == -1 && attacks[currAttack].hitboxes[attackFrame] == 0) {
            attackFrame = 0;
            currAttack = -1;
            queuedAttack = block;
            queuedString = "block";
        } else if (currAttack == block && attackFrame == blockTime - 1) {
            attackFrame--;
        }
    }
    this.formerMouse = game.input.mouse.button;

    if (currAttack != 0) {
	    attack();
    }

    checkCollisions();
}

function move() {
    if (currAttack == 0) { //attack lock
        var oldPlayerRotation = player.rotation;    
        player.rotation   = -game.math.angleBetween(game.input.activePointer.x, game.input.activePointer.y, player.x, player.y); 
        sword.rotation   += player.rotation - oldPlayerRotation;
        
        if (leftkey.isDown){
            player.position.x += -speed;
            sword.position.x  += -speed;
        }
        if (rightkey.isDown){
            player.position.x += speed;
            sword.position.x  += speed;
        }
        if (upkey.isDown){
            player.position.y += -speed;
            sword.position.y  += -speed;
        }
        if (downkey.isDown){
            player.position.y += speed;
            sword.position.y  += speed;
        }
    } else if (currAttack == -1) { //regain speed during sword return
        
        var oldPlayerRotation = player.rotation;    
        player.rotation += (-game.math.angleBetween(game.input.activePointer.x, game.input.activePointer.y, player.x, player.y)
                            -oldPlayerRotation)*(.02 + (attackFrame/returnTime)); 
        sword.rotation  += player.rotation - oldPlayerRotation;
        
        if (leftkey.isDown){
            player.position.x += -speed*(.2+(attackFrame/returnTime));
            sword.position.x  += -speed*(.2+(attackFrame/returnTime));
        }
        if (rightkey.isDown){
            player.position.x += speed*(.2+(attackFrame/returnTime));
            sword.position.x  += speed*(.2+(attackFrame/returnTime));
        }
        if (upkey.isDown){
            player.position.y += -speed*(.2+(attackFrame/returnTime));
            sword.position.y  += -speed*(.2+(attackFrame/returnTime));
        }
        if (downkey.isDown){
            player.position.y += speed*(.2+(attackFrame/returnTime));
            sword.position.y  += speed*(.2+(attackFrame/returnTime));
        }    
    } else { 
        var oldPlayerRotation = player.rotation;    
        player.rotation += (-game.math.angleBetween(game.input.activePointer.x, game.input.activePointer.y, player.x, player.y)
                            -oldPlayerRotation)*.02; 
        sword.rotation  += player.rotation - oldPlayerRotation;
        
        if (leftkey.isDown){
            player.position.x += -speed*.2;
            sword.position.x  += -speed*.2;
        }
        if (rightkey.isDown){
            player.position.x += speed*.2;
            sword.position.x  += speed*.2;
        }
        if (upkey.isDown){
            player.position.y += -speed*.2;
            sword.position.y  += -speed*.2;
        }
        if (downkey.isDown){
            player.position.y += speed*.2;
            sword.position.y  += speed*.2;
        }
    }
}

function checkCollisions(){
    if (currAttack > 0 && checkOverlap(sword, enemy) && attacks[currAttack].hitboxes[attackFrame] != 0 && !enemyHit) {
        enemyHit = 1;
        var damage = game.add.text(enemy.position.x + 30*(Math.random()-.5), enemy.position.y + 30*(Math.random()-.5),
                                   attacks[currAttack].hitboxes[attackFrame]);
        game.add.tween(damage).to({alpha: 0}, 1000, Phaser.Easing.Linear.None, true);
        enemyHealth -= attacks[currAttack].hitboxes[attackFrame];
        enemyHealthText.text = 'Enemy health: ' + enemyHealth;
    } 
}

function checkOverlap(spriteA, spriteB) {
    var boundsA = spriteA.getBounds();
    var boundsB = spriteB.getBounds();

    return Phaser.Rectangle.intersects(boundsA, boundsB);
}

function attack() {
    //return sword
    if (currAttack == -1) {
        if (attackFrame == 0) {
            sword.rotation %= 6.283;
            console.log(sword.rotation);
            console.log(player.rotation);
            console.log(sword.rotation - player.rotation);
            startingRotationDifference  = sword.rotation   - player.rotation;
            startingPositionDifferenceX = sword.position.x - player.position.x;
	        startingPositionDifferenceY = sword.position.y - player.position.y - 10;
        }    
        if (attackFrame == returnTime) {
	        currAttack = queuedAttack;
            attackString = queuedString;
	        attackFrame = 0;
            enemyHit = 0;
            return;
	    } else {
	        sword.rotation   -= startingRotationDifference /returnTime;
	        sword.position.x -= startingPositionDifferenceX/returnTime;
	        sword.position.y -= startingPositionDifferenceY/returnTime;
	    }
    } else {
    	if (attackFrame >= attacks[currAttack].frames) {
            queuedAttack = 0;
            attackString = "";
            queuedString = "";
            attackFrame = 0;
	        currAttack = -1;
	        return;
        }

        var movementFrameData = attacks[currAttack].movements[attackFrame];

    	sword.position.x += Math.cos(player.rotation)*movementFrameData[0] + Math.sin(player.rotation)*movementFrameData[1];
    	sword.position.y += Math.sin(player.rotation)*movementFrameData[0] + Math.cos(player.rotation)*movementFrameData[1];
    	sword.rotation   += attacks[currAttack].rotations[attackFrame];
    }


    attackFrame++;
}

var platforms;
var score = 0;
var scoreText;

function create() {
    game.canvas.oncontextmenu = function (e) { e.preventDefault(); }

    //  A simple background for our game
    game.add.sprite(0, 0, 'sky');

    // The player and its settings
    player = game.add.sprite(150, game.world.height - 150, 'dude');
    player.anchor.setTo(.5,.5);
    
    enemy  = game.add.sprite(300, game.world.height - 280, 'star');

    sword = game.add.sprite(150, game.world.height - 140, 'platform');
    sword.scale.setTo(.4,1.6);
    sword.anchor.setTo(0.5, 0.9);	

    //set player speed 
    speed = 3;

    //  We need to enable physics on the player
    //game.physics.arcade.enable(player);
    //game.physics.arcade.enable(sword);

    //  Player physics properties. Give the little guy a slight bounce.
    //player.body.collideWorldBounds = true;

    upkey = game.input.keyboard.addKey(Phaser.Keyboard.W);
    downkey = game.input.keyboard.addKey(Phaser.Keyboard.S);
    leftkey = game.input.keyboard.addKey(Phaser.Keyboard.A);
    rightkey = game.input.keyboard.addKey(Phaser.Keyboard.D);
    this.formerMouse = -1;

    attacking = false;
    currAttack = 0;
    attackFrame = 0;
    enemyHit = 0;
    enemyHealth  = 1000;
    enemyHealthText  = game.add.text(game.world.width - 300, 50, 'Enemy health: ' + enemyHealth, { fill: '#ffffff' });
    playerHealth = 1000;
    playerHealthText = game.add.text(50, 50, 'Player health: ' + playerHealth, { fill: '#ffffff' });

    jab1 = 2;
    jab2 = 1;
    jab3 = 2;
    block = 3;
    queuedAttack = 0;

    attacks[0] = new Attack(0, 0, [0,0],0,0);

    attacks[1] = new Attack(1, 17, 
	[[-2,.5],[-3,.5],[-2,.5],[-1,.5],[-.5,0],[-.5,0],[-.5,0], //windup
	 [0,0],[1,-.5],[2,-.5],[2,-.5],[3,0],[3,0],[3,0],[3,0],[3,0],[3,0],[3,0],[2,.5],[2,.5],[1,.5],[1,.5],[.5,.5],[0,.5]], //swing 
	[-.05,-.1,-.15,-.2,-.15,-.15,.1,0,.05,.75,.1,.125,.15,.175,.2,.175,.15,.1],//rotations
	[0,0,0,0,0,0,0,15,25,40,100,100,40,25,20,15,10]); //hitboxes

    attacks[2] = generateAttack(2, 68, [[-20,2,20,1],[60,10,28,1],[5,20,20,0]],[[-1.5,20, 1],[3,28,1],[.2,20,0]],[[0,20],[90,28],[0,20]]);
    attacks[3] = generateAttack(3, blockTime, [[-20,-20,blockTime-3,0],[0,0,3,0]],[[3.14/2,blockTime - 2,1],[0,2,0]],[[0,blockTime - 2],[0,2]]);
}

function generateAttack(num, totalFrames, movements, rotations, hitboxes){
    var currFrame = 0;
    var i, j;
    var tempMovements = new Array();
    var tempRotations = new Array();
    var tempHitboxes  = new Array();
	for (i = 0; i < movements.length; i++) {
        var frames = movements[i][2];
        for (j = 1; j <= frames; j++) {
            tempMovements[currFrame] = new Array(2);
            if (movements[i][3]) { //accelerated
                var factor = j < frames - j + 1 ? j : frames - j + 1;
                tempMovements[currFrame][0] = (factor)*(movements[i][0] / (2*triangleNumber(frames/2)));
                tempMovements[currFrame][1] = (factor)*(movements[i][1] / (2*triangleNumber(frames/2)));
            } else { 
                tempMovements[currFrame][0] = movements[i][0] / frames;
                tempMovements[currFrame][1] = movements[i][1] / frames;
            }    
            currFrame++;
        }
    }
    currFrame = 0;
	for (i = 0; i < rotations.length; i++) {
        var frames = rotations[i][1];
        for (j = 0; j < frames; j++) {
            if (rotations[i][2]) { //accelerated
                 var factor = j < frames - j + 1 ? j : frames - j + 1;
                 tempRotations[currFrame] = (factor)*(rotations[i][0] / (2*triangleNumber(frames/2)));
            } else {
                tempRotations[currFrame] = rotations[i][0] / frames;
            }    
            currFrame++;
        }
    }
    currFrame = 0;
	for (i = 0; i < hitboxes.length; i++) {
        var frames = hitboxes[i][1];
        for (j = 0; j < frames; j++) {
            tempHitboxes[currFrame] = hitboxes[i][0];
            currFrame++;
        }
    }
    
    return new Attack(num, totalFrames, tempMovements, tempRotations, tempHitboxes);
}

function triangleNumber(n)
{
    return (n*n+n)/2;
}
</script>

</body>
</html>
